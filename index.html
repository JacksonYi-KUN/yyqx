<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小男孩捡方块 | Three.js趣味小游戏</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: linear-gradient(120deg, #87CEEB, #98FB98); 
            font-family: "PingFang SC", "微软雅黑", sans-serif;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            padding: 12px 28px;
            border-radius: 24px;
            font-size: 22px;
            color: #2c3e50;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.8);
        }
        #tips {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #2c3e50;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(6px);
            padding: 10px 20px;
            border-radius: 18px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
    </style>
</head>
<body>
    <div id="score">得分：0</div>
    <div id="tips">WASD控制小男孩移动 | 碰到方块自动捡起 | 按R键重置 | 方块捡完自动刷新</div>

    <script type="module">
        // ===================== 1. 导入本地Three.js核心（路径不变！） =====================
        import * as THREE from './node_modules/three/build/three.module.js';

        // ===================== 2. 全局变量 =====================
        let scene, camera, renderer;
        let score = 0;
        const cubes = [];
        const cubeColors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xfeca57, 0xa8e6cf, 0xff8a80];
        let boy; 
        let audioContext;
        // 移动控制
        const boySpeed = 0.6; 
        const keys = { w: false, a: false, s: false, d: false };
        const moveLimit = 25; 
        // 碰撞检测用：包围盒
        const boyBox = new THREE.Box3(); // 小男孩包围盒
        const cubeBox = new THREE.Box3(); // 方块包围盒

        // ===================== 3. 初始化音频 =====================
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            window.playClickSound = () => {
                const oscillator = audioContext.createOscillator();
                const gain = audioContext.createGain();
                oscillator.connect(gain);
                gain.connect(audioContext.destination);
                oscillator.type = 'sine';
                oscillator.frequency.value = 800;
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            };
        }

        // ===================== 4. 初始化场景 =====================
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 20, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xfff8e1, 0.9);
            dirLight.position.set(15, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x7ccd7c,
                roughness: 0.8,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        // ===================== 5. 创建小男孩 =====================
        function createBoy() {
            boy = new THREE.Group();

            // 头部
            const headGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffd7ba });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 3;
            head.castShadow = true;
            boy.add(head);

            // 身体
            const bodyGeometry = new THREE.CylinderGeometry(0.7, 1, 2, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4a90e2 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            boy.add(body);

            // 手臂
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xffd7ba });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.8, 2, 0);
            leftArm.rotation.z = Math.PI / 6;
            boy.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.8, 2, 0);
            rightArm.rotation.z = -Math.PI / 6;
            boy.add(rightArm);

            // 腿
            const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.4, -0.5, 0);
            boy.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.4, -0.5, 0);
            boy.add(rightLeg);

            boy.position.set(0, 0, 0);
            scene.add(boy);

            // Idle动画（静止时）
            function animateBoyIdle() {
                const time = Date.now() * 0.001;
                if (!keys.w && !keys.a && !keys.s && !keys.d) {
                    boy.rotation.y = Math.sin(time * 0.8) * 0.1;
                    boy.position.y = Math.sin(time * 1.2) * 0.2;
                    leftArm.rotation.z = Math.PI / 6 + Math.sin(time * 1.5) * 0.08;
                    rightArm.rotation.z = -Math.PI / 6 + Math.sin(time * 1.5) * 0.08;
                }
                requestAnimationFrame(animateBoyIdle);
            }
            animateBoyIdle();
        }

        // ===================== 6. 生成随机方块（更分散） =====================
        function createRandomCube() {
            const size = 0.8 + Math.random() * 0.6;
            const x = (Math.random() - 0.5) * 20; 
            const y = 0.5 + Math.random() * 2;
            const z = (Math.random() - 0.5) * 18; 
            const color = cubeColors[Math.floor(Math.random() * cubeColors.length)];

            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.1,
                emissive: new THREE.Color(color).multiplyScalar(0.1)
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;

            cube.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.015,
                y: (Math.random() - 0.5) * 0.015
            };
            cube.jumpSpeed = Math.random() * 0.02;
            cube.jumpHeight = Math.random() * 0.5 + 0.2;
            cube.baseY = y;

            scene.add(cube);
            cubes.push(cube);
        }

        // ===================== 7. 生成方块 =====================
        function generateCubes(num = 12) {
            cubes.forEach(cube => {
                if (cube.parent) scene.remove(cube);
            });
            cubes.length = 0;
            for (let i = 0; i < num; i++) {
                createRandomCube();
            }
        }

        // ===================== 8. 碰撞检测捡方块（核心修改） =====================
        function checkCubeCollision() {
            if (!boy) return;

            // 1. 更新小男孩包围盒（适配缩放/旋转/位置）
            boyBox.setFromObject(boy);
            // 扩大一点包围盒（让碰撞更灵敏，不用精准贴脸）
            boyBox.expandByScalar(0.5);

            // 2. 遍历所有方块检测碰撞
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                cubeBox.setFromObject(cube);

                // 3. 检测碰撞
                if (boyBox.intersectsBox(cubeBox)) {
                    // 激活音频（浏览器策略）
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    // 移除方块（带动画）
                    const clickedCube = cube;
                    cubes.splice(i, 1);
                    const animateRemove = () => {
                        clickedCube.scale.x *= 0.95;
                        clickedCube.scale.y *= 0.95;
                        clickedCube.scale.z *= 0.95;
                        clickedCube.material.opacity *= 0.9;
                        if (clickedCube.scale.x > 0.1) {
                            requestAnimationFrame(animateRemove);
                        } else {
                            scene.remove(clickedCube);
                        }
                    };
                    animateRemove();

                    // 播放音效+更新得分
                    playClickSound();
                    score++;
                    document.getElementById('score').innerText = `得分：${score}`;

                    // 方块捡完自动刷新
                    if (cubes.length === 0) {
                        setTimeout(() => {
                            generateCubes();
                        }, 800);
                    }
                }
            }
        }

        // ===================== 9. 事件监听（移除点击，保留WASD/R） =====================
        function initEvents() {
            // WASD按键监听
            window.addEventListener('keydown', (event) => {
                switch(event.key.toLowerCase()) {
                    case 'w': keys.w = true; break;
                    case 'a': keys.a = true; break;
                    case 's': keys.s = true; break;
                    case 'd': keys.d = true; break;
                    case 'r': 
                        score = 0;
                        document.getElementById('score').innerText = `得分：${score}`;
                        generateCubes();
                        break;
                }
            });

            window.addEventListener('keyup', (event) => {
                switch(event.key.toLowerCase()) {
                    case 'w': keys.w = false; break;
                    case 'a': keys.a = false; break;
                    case 's': keys.s = false; break;
                    case 'd': keys.d = false; break;
                }
            });

            // 窗口适配
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ===================== 10. 动画循环（新增碰撞检测） =====================
        function animate() {
            requestAnimationFrame(animate);

            // 小男孩移动
            if (boy) {
                let moveX = 0;
                let moveZ = 0;

                if (keys.w) moveZ -= boySpeed;
                if (keys.s) moveZ += boySpeed;
                if (keys.a) moveX -= boySpeed;
                if (keys.d) moveX += boySpeed;

                const newX = boy.position.x + moveX;
                const newZ = boy.position.z + moveZ;
                if (Math.abs(newX) < moveLimit) boy.position.x = newX;
                if (Math.abs(newZ) < moveLimit) boy.position.z = newZ;

                if (moveX !== 0 || moveZ !== 0) {
                    const targetRotation = Math.atan2(moveX, -moveZ);
                    boy.rotation.y = THREE.MathUtils.lerp(boy.rotation.y, targetRotation, 0.1);
                }
            }

            // 碰撞检测（核心：每一帧检测）
            checkCubeCollision();

            // 方块动画
            cubes.forEach(cube => {
                cube.rotation.x += cube.rotationSpeed.x;
                cube.rotation.y += cube.rotationSpeed.y;
                cube.position.y = cube.baseY + Math.sin(Date.now() * cube.jumpSpeed) * cube.jumpHeight;
            });

            renderer.render(scene, camera);
        }

        // ===================== 11. 启动游戏 =====================
        function startGame() {
            initScene();
            initAudio();
            createBoy();
            generateCubes();
            initEvents(); // 改名为initEvents（移除了点击逻辑）
            animate();
        }

        startGame();
    </script>
</body>
</html>